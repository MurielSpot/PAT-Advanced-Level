/*
https://www.patest.cn/contests/pat-a-practise/1049
类型：计数（计算1的个数）。

难度：5（这题做得觉得自己太笨了。）

思路：
每次考虑某一位在1~n这些数内可能出现的次数。
令数为(left)x(right)，x为第k位（1代表个位），left表示k位左边若干位代表的数，right是右边。
当x==0，只有在左边取0~left-1时第k位才会出现1，此时右边可以取遍0到(9...9)，即对应每个第k位的1右边都可取一共10^right个数。如123045百位为1的情况有：0001##~1221##，共123*(10^2)中取法。所以此时1的个数为：left*(10^(k-1))。
当x==1，如123145可把它看成[0,123099]中的1，和[123100,123145]中的1之和。前面一个区间的1的个数同上为123*(10^2),后面的区间第k位的1的个数为46个，即right+1。所以x==1时，第k为1的个数为：left*(10^(k-1))+right+1。
当x>=2，如123545中，0001##~1231##百位都为1，共有(123+1)*(10^3)个。所以当x>=2时，第k位1的总个数为(left+1)*(10^(k-1))。

难点：在于怎么划分数来统计1的个数。
如：有数abcd。
 计算1的划分方法一：分别计算0~a000，a000~ab00，ab00~abc0,abc0~abcd中的1的个数再加在一起，虽然可以但是这种划分方法实现起来挺复杂的。（可以提前处理好x位数最多包含多少个1，也许可以帮助计算，如1位数最多1个1，2位数最多20个1，……。）
 计算1的划分方法二：分别计算abc1，ab1d，a1bc，1bcd，即分别计算每一位为1时的数量，只需要讨论该位以外其它位有多少中组和情况即可。（这种方法容易让人糊涂的一点在于，当确定一位为1的时候，其他位可能也为1，反过来其他位为1的时候，这个数也可能为1，从而多次计算该数对应的1，容易让人误以为这种方法会重复计算1的个数，其实不会。比如计算1234的时候，在abc1的情况下，1231对应一个1，而1bcd的情况下，1231又对应一个1，注意此时它们对应的是不同位的1，所以虽然都是1231这个数，但是对于它计算两个1是正确的。我又要把自己绕晕了。）
*/

#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;

int main(){
	int n;scanf("%d",&n);
	int left,now,right;
	int pow10k=1;
	int ans=0;
	while(n/pow10k!=0){
		left=n/(pow10k*10);
		now=n/pow10k%10;
		right=n%pow10k;
		if(now==0)ans+=left*pow10k;
		else if(now==1)ans+=left*pow10k+right+1;
		else ans+=(left+1)*pow10k;
		pow10k*=10;
	}
	printf("%d",ans);
	return 0;
}
